{
  "version": 3,
  "sources": ["../../regexparam/dist/index.mjs", "../../wouter/esm/index.js"],
  "sourcesContent": ["/**\n * @param {string|RegExp} input The route pattern\n * @param {boolean} [loose] Allow open-ended matching. Ignored with `RegExp` input.\n */\nexport function parse(input, loose) {\n\tif (input instanceof RegExp) return { keys:false, pattern:input };\n\tvar c, o, tmp, ext, keys=[], pattern='', arr = input.split('/');\n\tarr[0] || arr.shift();\n\n\twhile (tmp = arr.shift()) {\n\t\tc = tmp[0];\n\t\tif (c === '*') {\n\t\t\tkeys.push(c);\n\t\t\tpattern += tmp[1] === '?' ? '(?:/(.*))?' : '/(.*)';\n\t\t} else if (c === ':') {\n\t\t\to = tmp.indexOf('?', 1);\n\t\t\text = tmp.indexOf('.', 1);\n\t\t\tkeys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );\n\t\t\tpattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';\n\t\t\tif (!!~ext) pattern += (!!~o ? '?' : '') + '\\\\' + tmp.substring(ext);\n\t\t} else {\n\t\t\tpattern += '/' + tmp;\n\t\t}\n\t}\n\n\treturn {\n\t\tkeys: keys,\n\t\tpattern: new RegExp('^' + pattern + (loose ? '(?=$|\\/)' : '\\/?$'), 'i')\n\t};\n}\n\nvar RGX = /(\\/|^)([:*][^/]*?)(\\?)?(?=[/.]|$)/g;\n\n// error if key missing?\nexport function inject(route, values) {\n\treturn route.replace(RGX, (x, lead, key, optional) => {\n\t\tx = values[key=='*' ? key : key.substring(1)];\n\t\treturn x ? '/'+x : (optional || key=='*') ? '' : '/' + key;\n\t});\n}\n", "import { parse } from 'regexparam';\nimport { useBrowserLocation, useSearch as useSearch$1 } from './use-browser-location.js';\nimport { createContext, forwardRef, useEvent, isValidElement, cloneElement, createElement, useContext, useRef, useIsomorphicLayoutEffect, Fragment } from './react-deps.js';\n\n/*\n * Transforms `path` into its relative `base` version\n * If base isn't part of the path provided returns absolute path e.g. `~/app`\n */\nconst relativePath = (base = \"\", path) =>\n  !path.toLowerCase().indexOf(base.toLowerCase())\n    ? path.slice(base.length) || \"/\"\n    : \"~\" + path;\n\nconst absolutePath = (to, base = \"\") =>\n  to[0] === \"~\" ? to.slice(1) : base + to;\n\n/*\n * Removes leading question mark\n */\nconst stripQm = (str) => (str[0] === \"?\" ? str.slice(1) : str);\n\n/*\n * decodes escape sequences such as %20\n */\nconst unescape = (str) => {\n  try {\n    return decodeURI(str);\n  } catch (_e) {\n    // fail-safe mode: if string can't be decoded do nothing\n    return str;\n  }\n};\n\n/*\n * Router and router context. Router is a lightweight object that represents the current\n * routing options: how location is managed, base path etc.\n *\n * There is a default router present for most of the use cases, however it can be overridden\n * via the <Router /> component.\n */\n\nconst defaultRouter = {\n  hook: useBrowserLocation,\n  searchHook: useSearch$1,\n  parser: parse,\n  base: \"\",\n  // this option is used to override the current location during SSR\n  ssrPath: undefined,\n  ssrSearch: undefined,\n  // customizes how `href` props are transformed for <Link />\n  hrefs: (x) => x,\n};\n\nconst RouterCtx = createContext(defaultRouter);\n\n// gets the closest parent router from the context\nconst useRouter = () => useContext(RouterCtx);\n\n/**\n * Parameters context. Used by `useParams()` to get the\n * matched params from the innermost `Route` component.\n */\n\nconst ParamsCtx = createContext({});\n\nconst useParams = () => useContext(ParamsCtx);\n\n/*\n * Part 1, Hooks API: useRoute and useLocation\n */\n\n// Internal version of useLocation to avoid redundant useRouter calls\n\nconst useLocationFromRouter = (router) => {\n  const [location, navigate] = router.hook(router);\n\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  // (This is achieved via `useEvent`.)\n  return [\n    unescape(relativePath(router.base, location)),\n    useEvent((to, navOpts) => navigate(absolutePath(to, router.base), navOpts)),\n  ];\n};\n\nconst useLocation = () => useLocationFromRouter(useRouter());\n\nconst useSearch = () => {\n  const router = useRouter();\n  return unescape(stripQm(router.searchHook(router)));\n};\n\nconst matchRoute = (parser, route, path, loose) => {\n  // when parser is in \"loose\" mode, `$base` is equal to the\n  // first part of the route that matches the pattern\n  // (e.g. for pattern `/a/:b` and path `/a/1/2/3` the `$base` is `a/1`)\n  // we use this for route nesting\n  const { pattern, keys } = parser(route || \"*\", loose);\n  const [$base, ...matches] = pattern.exec(path) || [];\n\n  return $base !== undefined\n    ? [\n        true,\n\n        // an object with parameters matched, e.g. { foo: \"bar\" } for \"/:foo\"\n        // we \"zip\" two arrays here to construct the object\n        // [\"foo\"], [\"bar\"] â†’ { foo: \"bar\" }\n        Object.fromEntries(keys.map((key, i) => [key, matches[i]])),\n\n        // the third value if only present when parser is in \"loose\" mode,\n        // so that we can extract the base path for nested routes\n        ...(loose ? [$base] : []),\n      ]\n    : [false, null];\n};\n\nconst useRoute = (pattern) =>\n  matchRoute(useRouter().parser, pattern, useLocation()[0]);\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nconst Router = ({ children, ...props }) => {\n  // the router we will inherit from - it is the closest router in the tree,\n  // unless the custom `hook` is provided (in that case it's the default one)\n  const parent_ = useRouter();\n  const parent = props.hook ? defaultRouter : parent_;\n\n  // holds to the context value: the router object\n  let value = parent;\n\n  // when `ssrPath` contains a `?` character, we can extract the search from it\n  const [path, search] = props.ssrPath?.split(\"?\") ?? [];\n  if (search) (props.ssrSearch = search), (props.ssrPath = path);\n\n  // hooks can define their own `href` formatter (e.g. for hash location)\n  props.hrefs = props.hrefs ?? props.hook?.hrefs;\n\n  // what is happening below: to avoid unnecessary rerenders in child components,\n  // we ensure that the router object reference is stable, unless there are any\n  // changes that require reload (e.g. `base` prop changes -> all components that\n  // get the router from the context should rerender, even if the component is memoized).\n  // the expected behaviour is:\n  //\n  //   1) when the resulted router is no different from the parent, use parent\n  //   2) if the custom `hook` prop is provided, we always inherit from the\n  //      default router instead. this resets all previously overridden options.\n  //   3) when the router is customized here, it should stay stable between renders\n  let ref = useRef({}),\n    prev = ref.current,\n    next = prev;\n\n  for (let k in parent) {\n    const option =\n      k === \"base\"\n        ? /* base is special case, it is appended to the parent's base */\n          parent[k] + (props[k] || \"\")\n        : props[k] || parent[k];\n\n    if (prev === next && option !== next[k]) {\n      ref.current = next = { ...next };\n    }\n\n    next[k] = option;\n\n    // the new router is no different from the parent, use parent\n    if (option !== parent[k]) value = next;\n  }\n\n  return createElement(RouterCtx.Provider, { value, children });\n};\n\nconst h_route = ({ children, component }, params) => {\n  // React-Router style `component` prop\n  if (component) return createElement(component, { params });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\n\nconst Route = ({ path, nest, match, ...renderProps }) => {\n  const router = useRouter();\n  const [location] = useLocationFromRouter(router);\n\n  const [matches, params, base] =\n    // `match` is a special prop to give up control to the parent,\n    // it is used by the `Switch` to avoid double matching\n    match ?? matchRoute(router.parser, path, location, nest);\n\n  if (!matches) return null;\n\n  const children = base\n    ? createElement(Router, { base }, h_route(renderProps, params))\n    : h_route(renderProps, params);\n\n  return createElement(ParamsCtx.Provider, { value: params, children });\n};\n\nconst Link = forwardRef((props, ref) => {\n  const router = useRouter();\n  const [path, navigate] = useLocationFromRouter(router);\n\n  const {\n    to,\n    href: _href = to,\n    onClick: _onClick,\n    asChild,\n    children,\n    className: cls,\n    /* eslint-disable no-unused-vars */\n    replace /* ignore nav props */,\n    state /* ignore nav props */,\n    /* eslint-enable no-unused-vars */\n\n    ...restProps\n  } = props;\n\n  const onClick = useEvent((event) => {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (\n      event.ctrlKey ||\n      event.metaKey ||\n      event.altKey ||\n      event.shiftKey ||\n      event.button !== 0\n    )\n      return;\n\n    _onClick?.(event);\n    if (!event.defaultPrevented) {\n      event.preventDefault();\n      navigate(_href, props);\n    }\n  });\n\n  // handle nested routers and absolute paths\n  const href = router.hrefs(\n    _href[0] === \"~\" ? _href.slice(1) : router.base + _href,\n    router // pass router as a second argument for convinience\n  );\n\n  return asChild && isValidElement(children)\n    ? cloneElement(children, { onClick, href })\n    : createElement(\"a\", {\n        ...restProps,\n        onClick,\n        href,\n        // `className` can be a function to apply the class if this link is active\n        className: cls?.call ? cls(path === href) : cls,\n        children,\n        ref,\n      });\n});\n\nconst flattenChildren = (children) =>\n  Array.isArray(children)\n    ? children.flatMap((c) =>\n        flattenChildren(c && c.type === Fragment ? c.props.children : c)\n      )\n    : [children];\n\nconst Switch = ({ children, location }) => {\n  const router = useRouter();\n  const [originalLocation] = useLocationFromRouter(router);\n\n  for (const element of flattenChildren(children)) {\n    let match = 0;\n\n    if (\n      isValidElement(element) &&\n      // we don't require an element to be of type Route,\n      // but we do require it to contain a truthy `path` prop.\n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = matchRoute(\n        router.parser,\n        element.props.path,\n        location || originalLocation,\n        element.props.nest\n      ))[0]\n    )\n      return cloneElement(element, { match });\n  }\n\n  return null;\n};\n\nconst Redirect = (props) => {\n  const { to, href = to } = props;\n  const [, navigate] = useLocation();\n  const redirect = useEvent(() => navigate(to || href, props));\n\n  // redirect is guaranteed to be stable since it is returned from useEvent\n  useIsomorphicLayoutEffect(() => {\n    redirect();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return null;\n};\n\nexport { Link, Redirect, Route, Router, Switch, useLocation, useParams, useRoute, useRouter, useSearch };\n"],
  "mappings": ";;;;;;;;;;;AAIO,SAAS,MAAM,OAAO,OAAO;AACnC,MAAI,iBAAiB;AAAQ,WAAO,EAAE,MAAK,OAAO,SAAQ,MAAM;AAChE,MAAI,GAAG,GAAG,KAAK,KAAK,OAAK,CAAC,GAAG,UAAQ,IAAI,MAAM,MAAM,MAAM,GAAG;AAC9D,MAAI,CAAC,KAAK,IAAI,MAAM;AAEpB,SAAO,MAAM,IAAI,MAAM,GAAG;AACzB,QAAI,IAAI,CAAC;AACT,QAAI,MAAM,KAAK;AACd,WAAK,KAAK,CAAC;AACX,iBAAW,IAAI,CAAC,MAAM,MAAM,eAAe;AAAA,IAC5C,WAAW,MAAM,KAAK;AACrB,UAAI,IAAI,QAAQ,KAAK,CAAC;AACtB,YAAM,IAAI,QAAQ,KAAK,CAAC;AACxB,WAAK,KAAM,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,MAAM,IAAI,MAAM,CAAE;AAClE,iBAAW,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,mBAAmB;AAC9C,UAAI,CAAC,CAAC,CAAC;AAAK,oBAAY,CAAC,CAAC,CAAC,IAAI,MAAM,MAAM,OAAO,IAAI,UAAU,GAAG;AAAA,IACpE,OAAO;AACN,iBAAW,MAAM;AAAA,IAClB;AAAA,EACD;AAEA,SAAO;AAAA,IACN;AAAA,IACA,SAAS,IAAI,OAAO,MAAM,WAAW,QAAQ,YAAa,QAAS,GAAG;AAAA,EACvE;AACD;;;ACrBA,IAAM,eAAe,CAAC,OAAO,IAAI,SAC/B,CAAC,KAAK,YAAY,EAAE,QAAQ,KAAK,YAAY,CAAC,IAC1C,KAAK,MAAM,KAAK,MAAM,KAAK,MAC3B,MAAM;AAEZ,IAAM,eAAe,CAAC,IAAI,OAAO,OAC/B,GAAG,CAAC,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,OAAO;AAKvC,IAAM,UAAU,CAAC,QAAS,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM,CAAC,IAAI;AAK1D,IAAM,WAAW,CAAC,QAAQ;AACxB,MAAI;AACF,WAAO,UAAU,GAAG;AAAA,EACtB,SAAS,IAAI;AAEX,WAAO;AAAA,EACT;AACF;AAUA,IAAM,gBAAgB;AAAA,EACpB,MAAM;AAAA,EACN,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,MAAM;AAAA;AAAA,EAEN,SAAS;AAAA,EACT,WAAW;AAAA;AAAA,EAEX,OAAO,CAAC,MAAM;AAChB;AAEA,IAAM,gBAAY,4BAAc,aAAa;AAG7C,IAAM,YAAY,UAAM,yBAAW,SAAS;AAO5C,IAAM,gBAAY,4BAAc,CAAC,CAAC;AAElC,IAAM,YAAY,UAAM,yBAAW,SAAS;AAQ5C,IAAM,wBAAwB,CAAC,WAAW;AACxC,QAAM,CAAC,UAAU,QAAQ,IAAI,OAAO,KAAK,MAAM;AAK/C,SAAO;AAAA,IACL,SAAS,aAAa,OAAO,MAAM,QAAQ,CAAC;AAAA,IAC5C,SAAS,CAAC,IAAI,YAAY,SAAS,aAAa,IAAI,OAAO,IAAI,GAAG,OAAO,CAAC;AAAA,EAC5E;AACF;AAEA,IAAM,cAAc,MAAM,sBAAsB,UAAU,CAAC;AAE3D,IAAMA,aAAY,MAAM;AACtB,QAAM,SAAS,UAAU;AACzB,SAAO,SAAS,QAAQ,OAAO,WAAW,MAAM,CAAC,CAAC;AACpD;AAEA,IAAM,aAAa,CAAC,QAAQ,OAAO,MAAM,UAAU;AAKjD,QAAM,EAAE,SAAS,KAAK,IAAI,OAAO,SAAS,KAAK,KAAK;AACpD,QAAM,CAAC,OAAO,GAAG,OAAO,IAAI,QAAQ,KAAK,IAAI,KAAK,CAAC;AAEnD,SAAO,UAAU,SACb;AAAA,IACE;AAAA;AAAA;AAAA;AAAA,IAKA,OAAO,YAAY,KAAK,IAAI,CAAC,KAAK,MAAM,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC;AAAA;AAAA;AAAA,IAI1D,GAAI,QAAQ,CAAC,KAAK,IAAI,CAAC;AAAA,EACzB,IACA,CAAC,OAAO,IAAI;AAClB;AAEA,IAAM,WAAW,CAAC,YAChB,WAAW,UAAU,EAAE,QAAQ,SAAS,YAAY,EAAE,CAAC,CAAC;AAM1D,IAAM,SAAS,CAAC,EAAE,UAAU,GAAG,MAAM,MAAM;AA3H3C;AA8HE,QAAM,UAAU,UAAU;AAC1B,QAAM,SAAS,MAAM,OAAO,gBAAgB;AAG5C,MAAI,QAAQ;AAGZ,QAAM,CAAC,MAAM,MAAM,MAAI,WAAM,YAAN,mBAAe,MAAM,SAAQ,CAAC;AACrD,MAAI;AAAQ,IAAC,MAAM,YAAY,QAAU,MAAM,UAAU;AAGzD,QAAM,QAAQ,MAAM,WAAS,WAAM,SAAN,mBAAY;AAYzC,MAAI,UAAM,qBAAO,CAAC,CAAC,GACjB,OAAO,IAAI,SACX,OAAO;AAET,WAAS,KAAK,QAAQ;AACpB,UAAM,SACJ,MAAM;AAAA;AAAA,MAEF,OAAO,CAAC,KAAK,MAAM,CAAC,KAAK;AAAA,QACzB,MAAM,CAAC,KAAK,OAAO,CAAC;AAE1B,QAAI,SAAS,QAAQ,WAAW,KAAK,CAAC,GAAG;AACvC,UAAI,UAAU,OAAO,EAAE,GAAG,KAAK;AAAA,IACjC;AAEA,SAAK,CAAC,IAAI;AAGV,QAAI,WAAW,OAAO,CAAC;AAAG,cAAQ;AAAA,EACpC;AAEA,aAAO,4BAAc,UAAU,UAAU,EAAE,OAAO,SAAS,CAAC;AAC9D;AAEA,IAAM,UAAU,CAAC,EAAE,UAAU,UAAU,GAAG,WAAW;AAEnD,MAAI;AAAW,eAAO,4BAAc,WAAW,EAAE,OAAO,CAAC;AAGzD,SAAO,OAAO,aAAa,aAAa,SAAS,MAAM,IAAI;AAC7D;AAEA,IAAM,QAAQ,CAAC,EAAE,MAAM,MAAM,OAAO,GAAG,YAAY,MAAM;AACvD,QAAM,SAAS,UAAU;AACzB,QAAM,CAAC,QAAQ,IAAI,sBAAsB,MAAM;AAE/C,QAAM,CAAC,SAAS,QAAQ,IAAI;AAAA;AAAA;AAAA,IAG1B,SAAS,WAAW,OAAO,QAAQ,MAAM,UAAU,IAAI;AAAA;AAEzD,MAAI,CAAC;AAAS,WAAO;AAErB,QAAM,WAAW,WACb,4BAAc,QAAQ,EAAE,KAAK,GAAG,QAAQ,aAAa,MAAM,CAAC,IAC5D,QAAQ,aAAa,MAAM;AAE/B,aAAO,4BAAc,UAAU,UAAU,EAAE,OAAO,QAAQ,SAAS,CAAC;AACtE;AAEA,IAAM,WAAO,yBAAW,CAAC,OAAO,QAAQ;AACtC,QAAM,SAAS,UAAU;AACzB,QAAM,CAAC,MAAM,QAAQ,IAAI,sBAAsB,MAAM;AAErD,QAAM;AAAA,IACJ;AAAA,IACA,MAAM,QAAQ;AAAA,IACd,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA,WAAW;AAAA;AAAA,IAEX;AAAA,IACA;AAAA;AAAA,IAGA,GAAG;AAAA,EACL,IAAI;AAEJ,QAAM,UAAU,SAAS,CAAC,UAAU;AAGlC,QACE,MAAM,WACN,MAAM,WACN,MAAM,UACN,MAAM,YACN,MAAM,WAAW;AAEjB;AAEF,yCAAW;AACX,QAAI,CAAC,MAAM,kBAAkB;AAC3B,YAAM,eAAe;AACrB,eAAS,OAAO,KAAK;AAAA,IACvB;AAAA,EACF,CAAC;AAGD,QAAM,OAAO,OAAO;AAAA,IAClB,MAAM,CAAC,MAAM,MAAM,MAAM,MAAM,CAAC,IAAI,OAAO,OAAO;AAAA,IAClD;AAAA;AAAA,EACF;AAEA,SAAO,eAAW,6BAAe,QAAQ,QACrC,2BAAa,UAAU,EAAE,SAAS,KAAK,CAAC,QACxC,4BAAc,KAAK;AAAA,IACjB,GAAG;AAAA,IACH;AAAA,IACA;AAAA;AAAA,IAEA,YAAW,2BAAK,QAAO,IAAI,SAAS,IAAI,IAAI;AAAA,IAC5C;AAAA,IACA;AAAA,EACF,CAAC;AACP,CAAC;AAED,IAAM,kBAAkB,CAAC,aACvB,MAAM,QAAQ,QAAQ,IAClB,SAAS;AAAA,EAAQ,CAAC,MAChB,gBAAgB,KAAK,EAAE,SAAS,wBAAW,EAAE,MAAM,WAAW,CAAC;AACjE,IACA,CAAC,QAAQ;AAEf,IAAM,SAAS,CAAC,EAAE,UAAU,SAAS,MAAM;AACzC,QAAM,SAAS,UAAU;AACzB,QAAM,CAAC,gBAAgB,IAAI,sBAAsB,MAAM;AAEvD,aAAW,WAAW,gBAAgB,QAAQ,GAAG;AAC/C,QAAI,QAAQ;AAEZ,YACE,6BAAe,OAAO;AAAA;AAAA;AAAA;AAAA,KAKrB,QAAQ;AAAA,MACP,OAAO;AAAA,MACP,QAAQ,MAAM;AAAA,MACd,YAAY;AAAA,MACZ,QAAQ,MAAM;AAAA,IAChB,GAAG,CAAC;AAEJ,iBAAO,2BAAa,SAAS,EAAE,MAAM,CAAC;AAAA,EAC1C;AAEA,SAAO;AACT;AAEA,IAAM,WAAW,CAAC,UAAU;AAC1B,QAAM,EAAE,IAAI,OAAO,GAAG,IAAI;AAC1B,QAAM,CAAC,EAAE,QAAQ,IAAI,YAAY;AACjC,QAAM,WAAW,SAAS,MAAM,SAAS,MAAM,MAAM,KAAK,CAAC;AAG3D,4BAA0B,MAAM;AAC9B,aAAS;AAAA,EACX,GAAG,CAAC,CAAC;AAEL,SAAO;AACT;",
  "names": ["useSearch"]
}
